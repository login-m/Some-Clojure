;*********************

;(def get-args
 ; (fn [L e]
  ;  (if (empty? L)
   ;   '() true)))


    ;(concat (list 'if (concat '(=) (list (first L)) (list e))) (list (get-args (rest L) e))))))

(defmacro which
  (fn [S & args]
    (concat
      (list '(let [save (S)]))
      (list '(cond))
      ;(list (get-args args save)))))
       

;No recurrrsion?


;(map
 ; (fn [n]
  ;  (cond (< n 0) "negative"
   ;       (> n 0) "positive")) '(1 2  3 4))

;*********************

(def expand
  (fn [e]
    `(if ~e 1 0)))

(defmacro most [& args]
    `(if (> (+ ~@(map expand args)) ~(/ (count args) 2))
	    true false))
	    
;*********************

(def nest
  (fn [string N]
    (if (= N 0)
      'x
      (cons string (list (nest string (- N 1)))))))

(defmacro comps [fi k]
  (if (= k 0) '(fn [x] x)
  (if (= k 1) fi
  (concat '(let) (list (vector 'g# fi)) (list (concat '(fn [x]) (list (nest 'g# k))))))))
       
;*********************

(defmacro qrat [s a b c]
  (if (or (= a 0) (< (* b b) (* 4 (* a c))))
     nil
     (concat '(/)
      (list (concat (list s) (list (concat '(-) (list b)))
                                                           (list (concat '(Math/sqrt) (list (concat '(-) (list (list '* b b)) (list (concat (list '* 4) (list (list '* a c)))))))))) 
															
      (list (list '* 2 a)))))
   
;*********************

