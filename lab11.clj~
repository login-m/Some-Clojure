(declare satisfy)
(declare unpreceded)
(declare unpreceded?)
(declare precedes?)
(declare delete)

;NOTE #SUPERB:
; Finally understood how algorithm works.
; First, you look the the first element provided in the list
; and see if this element is at one's map
; YES -> go to the next one
; NO -> remove the object and add the element to the returning list. Start all over again.

; partial ordering example

(def partial-ordering 
  (atom (hash-map 
    'A  #{'C} 
    'B  #{'H} 
    'C  #{'G} 
    'G  #{'D 'E} 
    'D  #{'F} 
    'E  #{'H} 
    'H  #{'F} 
    'I  #{'B 'E})))

;A B C D E F G H I

; SATISFY

(def satisfy-helper
  (fn [precedes? objects L]
    (if (empty? (deref partial-ordering)) L
    (let [x (unpreceded unpreceded? precedes? objects)]
      (if (= x nil) 'vlad
        (do
	  (println x)
          (reset! partial-ordering (dissoc (deref partial-ordering) x))
	  (println objects)
	  (println (deref partial-ordering))
	  (println L)
          (recur precedes? (delete objects x) (concat L x))))))))




(def satisfy
  (fn [precedes? objects]
    (satisfy-helper precedes? objects '())))








; UNPRECEDED


;change someoweoweowa HERE

(def unpreceded
  (fn [etc precedes? objects]
    (loop [val (first objects)
           L objects
           traverse (rest objects)]
    (if (= val nil) nil
    (if (etc precedes? val L) val
	(recur (first traverse) L (rest traverse) ))))))



; UNPRECEDED?
; NOTE #1: Check the conditions, probably messed up somewhere
; NOTE #2: Check in the terminal how it works

(def some-helper
  (fn [P e S]
    (if (empty? S)
      false
    (if (P e (first S))
      true
    (recur P e (rest S))))))


(def unpreceded?
  (fn [precedes? object other-objects]
    (not (some-helper precedes? object other-objects))))










; PRECEDES?
; NOTE #1 - probably precedes? is the etc (continutation) for our functions

(def contains-helper
  (fn [S e]
    (if (empty? S)
      'false
    (if
       (= (first S) e) 'true
       (recur (rest S) e)))))

(def precedes?
  (fn [left right]
    (contains? (get (deref partial-ordering) right) left)))












; DELETE
; NOTE#1: Probably would need partial for some reason...

(def delete
  (fn [objects object]
    (remove (fn [x] (= x object)) objects)))


(satisfy precedes? '(A B C D E F G H I))
