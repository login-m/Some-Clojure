(declare lambda?)

; LAMBDA-SYMBOL? 

(def contains-helper
  (fn [s e]
    (if
      (empty? s) false
      (if
        (= (first s) e) true
	(recur (rest s) e)))))


(def lambda-symbol?
  (fn [N S]
    (contains-helper S N)))

;********************************

; LAMBDA-CALL?

(def lambda-call?
  (fn [L S]
    (if (symbol? (first L))
       (if (not (lambda-symbol? (first L) S))
          'false (lambda-call? (rest L) S))
    (if (list? (first L))
       (if (not (lambda-call? (first L) S))
          'false (lambda-call? (rest L) S)) 'true))))


;********************************

; LAMBDA-PARAMETERS?

(def unique?
  (fn [s]
    (if (not (empty? s))
      (if (contains-helper (rest s) (first s))
        'false
	 (recur (rest s)))
    'true)))


(def lambda-parameters?
  (fn [P]
    (and (vector? P) (unique? P))))


;********************************

; LAMBDA-FN?

(def mergevec
  (fn [new old]
    (if (empty? old) new
      (mergevec (conj new (first old)) (rest old)))))


(def lambda-fn?
  (fn [L S]
   (let [exp (last L)]
     (if (and (= 'fn (first L)) (lambda-parameters? (second L)))
       (lambda? exp (mergevec S (second L))) 'false))))


; merge the scopes?

;********************************

; LAMBDA?

(defn lambda?
  ([L] 
    (lambda? L (second L))) ;check if vector -> no add empty list
  ([L S]
    (let [exp (last L)]
     (if (symbol? exp) (lambda-symbol? exp S)
       (if (empty? exp) 'true
          (cond
	    (and (seq? exp) (not (= (first exp) 'fn))) (lambda-call? exp S) 'false
	    (and (seq? exp) (= (first exp) 'fn)) (lambda-fn? exp S) 'false))))))
         ;(and (lambda? (first exp) S) (lambda? (rest exp) S)))))))